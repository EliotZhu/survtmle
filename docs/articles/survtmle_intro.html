<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Targeted Learning for Survival Analysis with Competing Risks • survtmle</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Targeted Learning for Survival Analysis with Competing Risks">
<meta property="og:description" content="survtmle">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">survtmle</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.1.3</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/survtmle_intro.html">Targeted Learning for Survival Analysis with Competing Risks</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/benkeser/survtmle/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Targeted Learning for Survival Analysis with Competing Risks</h1>
                        <h4 class="author">
<a href="https://www.benkeserstatistics.com/">David Benkeser</a> &amp; <a href="https://nimahejazi.org">Nima Hejazi</a>
</h4>
            
            <h4 class="date">2020-06-06</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/benkeser/survtmle/blob/master/vignettes/survtmle_intro.Rmd"><code>vignettes/survtmle_intro.Rmd</code></a></small>
      <div class="hidden name"><code>survtmle_intro.Rmd</code></div>

    </div>

    
    
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p>The <code>survtmle</code> package is designed to use targeted minimum loss-based estimation (TMLE) to compute baseline covariate-adjusted estimates of marginal cumulative incidence in right-censored survival settings with (and without) competing risks. The package facilitates flexible modeling to adjust for covariates through the use of ensemble machine learning via the <a href="https://CRAN.R-project.org/package=SuperLearner"><code>SuperLearner</code></a> package.</p>
<hr>
</div>
<div id="single-failure-type" class="section level2">
<h2 class="hasAnchor">
<a href="#single-failure-type" class="anchor"></a>Single failure type</h2>
<p>We examine the use of <code>survtmle</code> in a variety of simple examples. The package can be loaded as follows:</p>
<div class="sourceCode" id="cb1"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="no">survtmle</span>)</pre></body></html></div>
<pre><code>## survtmle: Targeted Learning for Survival Analysis</code></pre>
<pre><code>## Version: 1.1.3</code></pre>
<p>We simulate a simple data with no censoring and a single cause of failure to illustrate the machinery of the <code>survtmle</code> package.</p>
<div class="sourceCode" id="cb4"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span>(<span class="fl">1234</span>)
<span class="no">n</span> <span class="kw">&lt;-</span> <span class="fl">200</span>
<span class="no">t_0</span> <span class="kw">&lt;-</span> <span class="fl">6</span>
<span class="no">trt</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">rbinom</a></span>(<span class="no">n</span>, <span class="fl">1</span>, <span class="fl">0.5</span>)
<span class="no">adjustVars</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(<span class="kw">W1</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span>(<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="no">n</span>)), <span class="kw">W2</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span>(<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="no">n</span>, <span class="fl">0</span>, <span class="fl">2</span>)))
<span class="no">ftime</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span>(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="no">n</span>, <span class="fl">1</span>, <span class="fl">4</span>) - <span class="no">trt</span> + <span class="no">adjustVars</span>$<span class="no">W1</span> + <span class="no">adjustVars</span>$<span class="no">W2</span>)
<span class="no">ftype</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span>(<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="no">n</span>, <span class="fl">0</span>, <span class="fl">1</span>))</pre></body></html></div>
<p>The simple data structure contains a set of baseline covariates (<code>adjustVars</code>), a binary treatment variable (<code>trt</code>), a failure time that is a function of the treatment, adjustment variables, and a random error (<code>ftime</code>), and a failure type (<code>ftype</code>), which denotes the cause of failure (0 means no failure, 1 means failure). The first few rows of data can be viewed as follows.</p>
<pre><code>## Warning: `as_data_frame()` is deprecated as of tibble 2.0.0.
## Please use `as_tibble()` instead.
## The signature and semantics have changed, see `?as_tibble`.
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_warnings()` to see where this warning was generated.</code></pre>
<pre><code>## # A tibble: 200 x 5
##    ftype ftime   trt    W1    W2
##    &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1     0     5     0     1     1
##  2     1     4     1     1     1
##  3     1     4     1     0     2
##  4     0     6     1     1     2
##  5     0     4     1     1     1
##  6     1     3     1     1     0
##  7     0     7     0     0     2
##  8     0     3     0     0     0
##  9     1     4     1     0     1
## 10     0     4     1     1     1
## # … with 190 more rows</code></pre>
<p>It is important to note that the current <code>survtmle</code> distribution <strong>only supports integer-valued failure times</strong>. If failure times are continuous-valued, then, unfortunately, we require the user to perform an additional pre-processing step to convert the observed failure times to ranked integers prior to applying the <code>survtmle</code> function. We hope to build support for this situation in future versions of the package.</p>
<hr>
<div id="using-the-method-of-iterated-means" class="section level3">
<h3 class="hasAnchor">
<a href="#using-the-method-of-iterated-means" class="anchor"></a>Using the method of iterated means</h3>
<div id="covariate-adjustment-via-logistic-regression" class="section level4">
<h4 class="hasAnchor">
<a href="#covariate-adjustment-via-logistic-regression" class="anchor"></a>Covariate adjustment via logistic regression</h4>
<p>A common goal is to compare the incidence of failure at a fixed time between the two treatment groups. Covariate adjustment is often desirable in this comparison to improve efficiency <span class="citation">(Moore and Laan 2009)</span>. This covariate adjustment may be facilitated by estimating a series of iterated covariate-conditional means <span class="citation">(Robins 1999,<span class="citation">@bang2005doubly</span>,<span class="citation">@vdlgruber:2012:ijb</span>)</span>. The final iterated covariate-conditional mean is marginalized over the empirical distribution of baseline covariates to obtain an estimate of the marginal cumulative incidence.</p>
<p>Here, we invoke the eponymous <code>survtmle</code> function to compute the iterated mean-based (<code>method = "mean"</code>) covariate-adjusted estimates of the cumulative incidence at time six (<code>t0 = 6</code>) in each of the treatment groups using quasi-logistic regression (formula specified via <code>glm.ftime</code>) to estimate the iterated means. The <code>glm.ftime</code> argument should be a valid right-hand-side formula specification based on <code><a href="https://rdrr.io/r/base/colnames.html">colnames(adjustVars)</a></code> and <code>"trt"</code>. Here we use a simple main terms regression.</p>
<div class="sourceCode" id="cb7"><html><body><pre class="r"><span class="co"># Fit 1: Use GLM-based estimators for failure w/ "mean" method</span>
<span class="no">fit1</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="kw">ftime</span> <span class="kw">=</span> <span class="no">ftime</span>, <span class="kw">ftype</span> <span class="kw">=</span> <span class="no">ftype</span>,
                 <span class="kw">trt</span> <span class="kw">=</span> <span class="no">trt</span>, <span class="kw">adjustVars</span> <span class="kw">=</span> <span class="no">adjustVars</span>,
                 <span class="kw">glm.ftime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="kw">method</span> <span class="kw">=</span> <span class="st">"mean"</span>, <span class="kw">t0</span> <span class="kw">=</span> <span class="no">t_0</span>)</pre></body></html></div>
<pre><code>## Warning in checkInputs(ftime = ftime, ftype = ftype, trt = trt, t0 = t0, :
## glm.trt and SL.trt not specified. Proceeding with glm.trt = '1'</code></pre>
<pre><code>## Warning in checkInputs(ftime = ftime, ftype = ftype, trt = trt, t0 = t0, :
## glm.ctime and SL.ctime not specified. Computing Kaplan-Meier estimates.</code></pre>
<pre><code>## Warning in chol.default(B, pivot = TRUE): the matrix is either rank-deficient or
## indefinite</code></pre>
<div class="sourceCode" id="cb11"><html><body><pre class="r"><span class="no">fit1</span></pre></body></html></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5667312
## 1 1 0.7353291
## 
## $var
##              0 1          1 1
## 0 1 0.0261215098 0.0002153689
## 1 1 0.0002153689 0.0185303036</code></pre>
<p>Internally, <code>survtmle</code> estimates the covariate-conditional treatment probability (via <code>glm.trt</code> or <code>SL.trt</code>, see below) and covariate-conditional censoring distribution (via <code>glm.ctime</code> or <code>SL.ctime</code>, see below). In the above example, the treatment probability does not depend on covariates (as in e.g., a randomized trial) and so we did not specify a way to adjust for covariates in estimating the treatment probability. In this case, <code>survtmle</code> sets <code>glm.trt = "1"</code>, which corresponds with empirical estimates of treatment probability, and sets <code>glm.ctime</code> to be equivalent to the Kaplan-Meier censoring distribution estimates.</p>
<p>In practice, we may wish to adjust for covariates when computing estimates of the covariate-conditional treatment and censoring probabilities. In observational studies, the distribution of treatment may differ by measured covariates, while in almost any study (including randomized trials) it is possible that censoring differs by covariates. Thus, we often wish to adjust for covariates to account for measured confounders of treatment receipt and censoring.</p>
<p>This adjustment may be accomplished using logistic regression through the <code>glm.trt</code> and <code>glm.ctime</code> arguments, respectively. The <code>glm.trt</code> argument should be a valid right-hand-side formula specification based on <code><a href="https://rdrr.io/r/base/colnames.html">colnames(adjustVars)</a></code>. The <code>glm.ctime</code> argument should be a valid right-hand-side formula specification based on <code><a href="https://rdrr.io/r/base/colnames.html">colnames(adjustVars)</a></code>, <code>"trt"</code>, and <code>"t"</code> used to model the hazard function for censoring. By including <code>"trt"</code> and <code>"t"</code>, the function allows censoring probabilities to depend on treatment assignment and time, respectively. Here we call <code>survtmle</code> again, now adjusting for covariates in the treatment and censoring fits.</p>
<div class="sourceCode" id="cb13"><html><body><pre class="r"><span class="co"># Fit 2: Use GLM-based estimators for failure, treatment, and censoring with</span>
<span class="co">#        the "mean" method</span>
<span class="no">fit2</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="kw">ftime</span> <span class="kw">=</span> <span class="no">ftime</span>, <span class="kw">ftype</span> <span class="kw">=</span> <span class="no">ftype</span>,
                 <span class="kw">trt</span> <span class="kw">=</span> <span class="no">trt</span>, <span class="kw">adjustVars</span> <span class="kw">=</span> <span class="no">adjustVars</span>,
                 <span class="kw">glm.trt</span> <span class="kw">=</span> <span class="st">"W1 + W2"</span>,
                 <span class="kw">glm.ctime</span> <span class="kw">=</span> <span class="st">"W1 + trt + t + I(t^2)"</span>,
                 <span class="kw">glm.ftime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="kw">method</span> <span class="kw">=</span> <span class="st">"mean"</span>, <span class="kw">t0</span> <span class="kw">=</span> <span class="no">t_0</span>)
<span class="no">fit2</span></pre></body></html></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5657950
## 1 1 0.7411658
## 
## $var
##              0 1          1 1
## 0 1 0.0029470633 0.0002170549
## 1 1 0.0002170549 0.0016411250</code></pre>
</div>
<div id="covariate-adjustment-via-super-learner" class="section level4">
<h4 class="hasAnchor">
<a href="#covariate-adjustment-via-super-learner" class="anchor"></a>Covariate adjustment via Super Learner</h4>
<p>While we can certainly use logistic regression to model the treatment, censoring, and iterated means, a large benefit afforded by the <code>survtmle</code> package is how it leverages <code>SuperLearner</code> ensemble machine learning to estimate these quantities in a more flexible manner. The Super Learner method is a generalization of stacked regression <span class="citation">(Breiman 1996)</span> that uses cross-validation to select the best-performing estimator from a library of candidate estimators <span class="citation">(Laan, Polley, and Hubbard 2007)</span>. Many popular machine learning algorithms have been implemented in the <a href="https://cran.r-project.org/package=SuperLearner"><code>SuperLearner</code></a>.</p>
<p>To utilize <code>SuperLearner</code> estimates, we can utilize options <code>SL.trt</code>, <code>SL.ctime</code>, and <code>SL.ftime</code> to estimate conditional treatment, censoring, and iterated means, respectively. See <code>?SuperLearner</code> for details on options for correctly specifying a super learner library and see <code>listWrappers()</code> to print the methods implemented in the <code>SuperLearner</code> package. Here we demonstrate a call to <code>survtmle</code> using a simple library that includes simple algorithms that are included in base <code>R</code>.</p>
<div class="sourceCode" id="cb15"><html><body><pre class="r"><span class="co"># Fit 3: SuperLearner estimators for treatment, failure, and censoring.</span>
<span class="no">fit3</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="kw">ftime</span> <span class="kw">=</span> <span class="no">ftime</span>, <span class="kw">ftype</span> <span class="kw">=</span> <span class="no">ftype</span>,
                 <span class="kw">trt</span> <span class="kw">=</span> <span class="no">trt</span>, <span class="kw">adjustVars</span> <span class="kw">=</span> <span class="no">adjustVars</span>,
                 <span class="kw">SL.trt</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                 <span class="kw">SL.ftime</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                 <span class="kw">SL.ctime</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                 <span class="kw">method</span> <span class="kw">=</span> <span class="st">"mean"</span>, <span class="kw">t0</span> <span class="kw">=</span> <span class="no">t_0</span>)</pre></body></html></div>
<pre><code>## Loading required package: nnls</code></pre>
<div class="sourceCode" id="cb17"><html><body><pre class="r"><span class="no">fit3</span></pre></body></html></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5549964
## 1 1 0.7030729
## 
## $var
##              0 1          1 1
## 0 1 0.0027827002 0.0001810706
## 1 1 0.0001810706 0.0017976563</code></pre>
<p><strong>Remark:</strong> Invoking <code>survtmle</code> with <code>method = "mean"</code> and <code>SL.ftime</code> requires fitting a Super Learner <em>for each time point</em> from <code><a href="https://rdrr.io/r/base/seq.html">seq_len(t0)</a></code>. If there are many unique time points observed in the data, this can become a computationally intensive process. In such cases, we recommend either redefining the <code>ftime</code> variable to pool across time points <em>or</em> using <code>method = "hazard"</code> (see below).</p>
<hr>
</div>
</div>
<div id="using-the-method-of-cause-specific-hazards" class="section level3">
<h3 class="hasAnchor">
<a href="#using-the-method-of-cause-specific-hazards" class="anchor"></a>Using the method of cause-specific hazards</h3>
<p>An alternative method to the iterated mean-based TMLE for estimating cumulative incidence is based on estimated the (cause-specific) hazard function. This estimator is implemented by specifying <code>method = "hazard"</code> in a call to <code>survtmle</code>. Just as with <code>method = "mean"</code>, we can use either <code>glm.</code> or <code>SL.</code> to adjust for covariates. However, now the <code>glm.ftime</code> formula may additionally include functions of time, as this formula is now being used in a pooled regression to estimate cause-specific hazards over time.</p>
<div class="sourceCode" id="cb19"><html><body><pre class="r"><span class="co"># Fit 4: GLM estimators for treatment, censoring, and failure w/ "hazard" method</span>
<span class="co"># Note the inclusion of 't' in the formula for glm.ftime.</span>
<span class="no">fit4</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="kw">ftime</span> <span class="kw">=</span> <span class="no">ftime</span>, <span class="kw">ftype</span> <span class="kw">=</span> <span class="no">ftype</span>,
                 <span class="kw">trt</span> <span class="kw">=</span> <span class="no">trt</span>, <span class="kw">adjustVars</span> <span class="kw">=</span> <span class="no">adjustVars</span>,
                 <span class="kw">glm.trt</span> <span class="kw">=</span> <span class="st">"W1 + W2"</span>,
                 <span class="kw">glm.ftime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2 + t + I(t^2)"</span>,
                 <span class="kw">glm.ctime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2*t"</span>,
                 <span class="kw">method</span> <span class="kw">=</span> <span class="st">"hazard"</span>, <span class="kw">t0</span> <span class="kw">=</span> <span class="no">t_0</span>)
<span class="no">fit4</span></pre></body></html></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5864610
## 1 1 0.7788141
## 
## $var
##              0 1          1 1
## 0 1 0.0028138563 0.0002638809
## 1 1 0.0002638809 0.0018133124</code></pre>
<p>Here’s an example using Super Learner.</p>
<div class="sourceCode" id="cb21"><html><body><pre class="r"><span class="co"># Fit 5: SuperLearner estimators for failure and censoring, alongside empirical</span>
<span class="co">#        estimators for treatment (the default) using the "hazard" method.</span>
<span class="co">#        Note that the super learner for ftime is also adjusting for time.</span>
<span class="no">fit5</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="kw">ftime</span> <span class="kw">=</span> <span class="no">ftime</span>, <span class="kw">ftype</span> <span class="kw">=</span> <span class="no">ftype</span>,
                 <span class="kw">trt</span> <span class="kw">=</span> <span class="no">trt</span>, <span class="kw">adjustVars</span> <span class="kw">=</span> <span class="no">adjustVars</span>,
                 <span class="kw">SL.trt</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"SL.glm"</span>, <span class="st">"SL.mean"</span>, <span class="st">"SL.step"</span>),
                 <span class="kw">SL.ftime</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"SL.glm"</span>, <span class="st">"SL.mean"</span>, <span class="st">"SL.step"</span>),
                 <span class="kw">SL.ctime</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"SL.glm"</span>, <span class="st">"SL.mean"</span>, <span class="st">"SL.step"</span>),
                 <span class="kw">method</span> <span class="kw">=</span> <span class="st">"hazard"</span>, <span class="kw">t0</span> <span class="kw">=</span> <span class="no">t_0</span>)
<span class="no">fit5</span></pre></body></html></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5852444
## 1 1 0.7580051
## 
## $var
##              0 1          1 1
## 0 1 0.0026806641 0.0002155895
## 1 1 0.0002155895 0.0020802570</code></pre>
<p><strong>Remark:</strong> The TMLE algorithm for the hazard-based estimator differs from the iterated mean-based TMLE. In particular, the algorithm is iterative and has no guarantee of convergence. While we have not identified instances where convergence is a serious problem, we encourage users to submit any such situations as <a href="https://github.com/benkeser/survtmle/issues">GitHub issues</a> or to write directly to <a href="mailto:benkeser@emory.edu">benkeser@emory.edu</a>. The stopping criteria for the iteration may be adjusted via <code>tol</code> and <code>maxIter</code> options. Increasing <code>tol</code> or decreasing <code>maxIter</code> will lead to faster convergence; however, it is recommended that <code>tol</code> be set no larger than <code>1 / sqrt(length(ftime))</code>. If <code>maxIter</code> is reached without convergence, one should check that <code>fit$meanIC</code> are all less than <code>1 / sqrt(length(ftime))</code>.</p>
<hr>
</div>
</div>
<div id="multiple-failure-types" class="section level2">
<h2 class="hasAnchor">
<a href="#multiple-failure-types" class="anchor"></a>Multiple failure types</h2>
<p>In all of the preceding examples, we have restricted our attention to the case where there is only a single failure type of interest. Now we consider more scenarios where we observe multiple failure types. First, we simulate data with two types of failure.</p>
<div class="sourceCode" id="cb23"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span>(<span class="fl">1234</span>)
<span class="no">n</span> <span class="kw">&lt;-</span> <span class="fl">200</span>
<span class="no">trt</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">rbinom</a></span>(<span class="no">n</span>, <span class="fl">1</span>, <span class="fl">0.5</span>)
<span class="no">adjustVars</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(<span class="kw">W1</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span>(<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="no">n</span>)), <span class="kw">W2</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span>(<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="no">n</span>, <span class="fl">0</span>, <span class="fl">2</span>)))
<span class="no">ftime</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span>(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="no">n</span>, <span class="fl">1</span>, <span class="fl">4</span>) - <span class="no">trt</span> + <span class="no">adjustVars</span>$<span class="no">W1</span> + <span class="no">adjustVars</span>$<span class="no">W2</span>)
<span class="no">ftype</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span>(<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="no">n</span>, <span class="fl">0</span>, <span class="fl">2</span>))</pre></body></html></div>
<p>This simulated data structure is similar to the single failure type data; however, now the failure type variable (<code>ftype</code>) now contains two distinct types of failure (with 0 still reserved for no failure).</p>
<pre><code>## # A tibble: 200 x 5
##    ftype ftime   trt    W1    W2
##    &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1     0     5     0     1     1
##  2     2     4     1     1     1
##  3     1     4     1     0     2
##  4     1     6     1     1     2
##  5     1     4     1     1     1
##  6     1     3     1     1     0
##  7     0     7     0     0     2
##  8     1     3     0     0     0
##  9     1     4     1     0     1
## 10     1     4     1     1     1
## # … with 190 more rows</code></pre>
<p>When multiple failure types are present, a common goal is to compare the cumulative incidence of a particular failure type at a fixed time between the two treatment groups, while accounting for the fact that participants may fail due to other failure types. Covariate adjustment is again desirable to improve efficiency and account for measured confounders of treatment and censoring.</p>
<div id="using-the-method-of-iterated-means-1" class="section level3">
<h3 class="hasAnchor">
<a href="#using-the-method-of-iterated-means-1" class="anchor"></a>Using the method of iterated means</h3>
<div id="covariate-adjustment-via-logistic-regression-1" class="section level4">
<h4 class="hasAnchor">
<a href="#covariate-adjustment-via-logistic-regression-1" class="anchor"></a>Covariate adjustment via logistic regression</h4>
<p>The call to invoke <code>survtmle</code> is exactly the same as in the single failure type case.</p>
<div class="sourceCode" id="cb25"><html><body><pre class="r"><span class="co"># Fit 6: GLM estimators for treatment, censoring, and failure w/ "mean" method</span>
<span class="no">fit6</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="kw">ftime</span> <span class="kw">=</span> <span class="no">ftime</span>, <span class="kw">ftype</span> <span class="kw">=</span> <span class="no">ftype</span>,
                 <span class="kw">trt</span> <span class="kw">=</span> <span class="no">trt</span>, <span class="kw">adjustVars</span> <span class="kw">=</span> <span class="no">adjustVars</span>,
                 <span class="kw">glm.trt</span> <span class="kw">=</span> <span class="st">"W1 + W2"</span>,
                 <span class="kw">glm.ftime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="kw">glm.ctime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="kw">method</span> <span class="kw">=</span> <span class="st">"mean"</span>, <span class="kw">t0</span> <span class="kw">=</span> <span class="no">t_0</span>)
<span class="no">fit6</span></pre></body></html></div>
<pre><code>## $est
##          [,1]
## 0 1 0.4229114
## 1 1 0.6029411
## 0 2 0.2517493
## 1 2 0.2968020
## 
## $var
##               0 1           1 1           0 2           1 2
## 0 1  3.518965e-03  2.105261e-05 -1.689263e-03  5.957709e-05
## 1 1  2.105261e-05  3.227379e-03 -2.396184e-05 -2.382514e-03
## 0 2 -1.689263e-03 -2.396184e-05  2.544764e-03  7.728650e-05
## 1 2  5.957709e-05 -2.382514e-03  7.728650e-05  2.615476e-03</code></pre>
<p>The output object contains cumulative incidence estimates for each of the four groups defined by the two failure types and treatments.</p>
<p>There are sometimes failure types that are not of direct interest to out study. Because <code>survtmle</code> invoked with <code>method = "mean"</code> computes an estimate of the cumulative incidence of each failure type separately, we can save on computation time by specifying which failure types we care about via the <code>ftypeOfInterest</code> option.</p>
<div class="sourceCode" id="cb27"><html><body><pre class="r"><span class="co"># Fit 7: GLM estimators for treatment, censoring, and failure w/ "mean" method</span>
<span class="no">fit7</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="kw">ftime</span> <span class="kw">=</span> <span class="no">ftime</span>, <span class="kw">ftype</span> <span class="kw">=</span> <span class="no">ftype</span>,
                 <span class="kw">trt</span> <span class="kw">=</span> <span class="no">trt</span>, <span class="kw">adjustVars</span> <span class="kw">=</span> <span class="no">adjustVars</span>,
                 <span class="kw">glm.trt</span> <span class="kw">=</span> <span class="st">"W1 + W2"</span>,
                 <span class="kw">glm.ftime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="kw">glm.ctime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="kw">method</span> <span class="kw">=</span> <span class="st">"mean"</span>, <span class="kw">t0</span> <span class="kw">=</span> <span class="no">t_0</span>,
                 <span class="kw">ftypeOfInterest</span> <span class="kw">=</span> <span class="fl">1</span>)
<span class="no">fit7</span></pre></body></html></div>
<pre><code>## $est
##          [,1]
## 0 1 0.4229114
## 1 1 0.6029411
## 
## $var
##              0 1          1 1
## 0 1 3.518965e-03 2.105261e-05
## 1 1 2.105261e-05 3.227379e-03</code></pre>
</div>
<div id="covariate-adjustment-via-super-learner-1" class="section level4">
<h4 class="hasAnchor">
<a href="#covariate-adjustment-via-super-learner-1" class="anchor"></a>Covariate adjustment via Super Learner</h4>
<p>As before, we can use the <code>SuperLearner</code> ensemble learning algorithm to adjust for covariates in multiple failure type settings as well.</p>
<div class="sourceCode" id="cb29"><html><body><pre class="r"><span class="co"># Fit 8: SuperLearner estimators for failure and censoring and empirical</span>
<span class="co">#        estimators for treatment (default) using the "mean" method.</span>
<span class="no">fit8</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="kw">ftime</span> <span class="kw">=</span> <span class="no">ftime</span>, <span class="kw">ftype</span> <span class="kw">=</span> <span class="no">ftype</span>,
                 <span class="kw">trt</span> <span class="kw">=</span> <span class="no">trt</span>, <span class="kw">adjustVars</span> <span class="kw">=</span> <span class="no">adjustVars</span>,
                 <span class="kw">SL.trt</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                 <span class="kw">SL.ftime</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                 <span class="kw">SL.ctime</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                 <span class="kw">method</span> <span class="kw">=</span> <span class="st">"mean"</span>, <span class="kw">t0</span> <span class="kw">=</span> <span class="no">t_0</span>)
<span class="no">fit8</span></pre></body></html></div>
<pre><code>## $est
##          [,1]
## 0 1 0.4383856
## 1 1 0.6010818
## 0 2 0.2467913
## 1 2 0.2655850
## 
## $var
##               0 1           1 1           0 2           1 2
## 0 1  2.647338e-03  1.664337e-05 -1.268230e-03  3.235180e-05
## 1 1  1.664337e-05  2.465004e-03  1.656666e-06 -1.668038e-03
## 0 2 -1.268230e-03  1.656666e-06  2.072453e-03  4.130544e-05
## 1 2  3.235180e-05 -1.668038e-03  4.130544e-05  1.944617e-03</code></pre>
<p><strong>Remark:</strong> As with single failure type, the <code>method = "mean"</code> call to <code>survtmle</code> may be computationally intensive with many time points. This is especially true when there are additionally multiple failure types, as the function must repeat these calls to <code>SuperLearner</code> separately for each type of failure. In this case, calls to <code>survtmle</code> could be parallelized with one call to <code>survtmle</code> for each type of failure specifying <code>ftypeOfInterest</code>.</p>
</div>
</div>
<div id="using-the-method-of-cause-specific-hazards-1" class="section level3">
<h3 class="hasAnchor">
<a href="#using-the-method-of-cause-specific-hazards-1" class="anchor"></a>Using the method of cause-specific hazards</h3>
<div id="covariate-adjustment-via-logistic-regression-2" class="section level4">
<h4 class="hasAnchor">
<a href="#covariate-adjustment-via-logistic-regression-2" class="anchor"></a>Covariate adjustment via logistic regression</h4>
<p>The TMLE based on cause-specific hazards can also be used to compute cumulative incidence estimates in settings with multiple failure types. As above, the <code>glm.ftime</code> formula may additionally include functions of time, as this formula is now being used in a pooled regression to estimate cause-specific hazard of each failure type over time.</p>
<div class="sourceCode" id="cb31"><html><body><pre class="r"><span class="co"># Fit 9: same as Fit 8 above, but using the "hazard" method</span>
<span class="no">fit9</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="kw">ftime</span> <span class="kw">=</span> <span class="no">ftime</span>, <span class="kw">ftype</span> <span class="kw">=</span> <span class="no">ftype</span>,
                 <span class="kw">trt</span> <span class="kw">=</span> <span class="no">trt</span>, <span class="kw">adjustVars</span> <span class="kw">=</span> <span class="no">adjustVars</span>,
                 <span class="kw">glm.trt</span> <span class="kw">=</span> <span class="st">"W1 + W2"</span>,
                 <span class="kw">glm.ftime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="kw">glm.ctime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="kw">method</span> <span class="kw">=</span> <span class="st">"hazard"</span>, <span class="kw">t0</span> <span class="kw">=</span> <span class="no">t_0</span>)
<span class="no">fit9</span></pre></body></html></div>
<pre><code>## $est
##          [,1]
## 0 1 0.4590612
## 1 1 0.6314466
## 0 2 0.2659013
## 1 2 0.2751953
## 
## $var
##               0 1           1 1           0 2           1 2
## 0 1  3.516292e-03 -1.629697e-03  5.883916e-05 -4.525266e-05
## 1 1 -1.629697e-03  2.505506e-03 -5.379741e-05  8.922855e-05
## 0 2  5.883916e-05 -5.379741e-05  3.877006e-03 -3.037918e-03
## 1 2 -4.525266e-05  8.922855e-05 -3.037918e-03  3.410066e-03</code></pre>
<p>We can also leverage the <code>SuperLearner</code> algorithm when using the method of cause-specific hazards with multiple failure types of interest.</p>
<div class="sourceCode" id="cb33"><html><body><pre class="r"><span class="co"># Fit 10: same as Fit 7 above, but using the "hazard" method</span>
<span class="no">fit10</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="kw">ftime</span> <span class="kw">=</span> <span class="no">ftime</span>, <span class="kw">ftype</span> <span class="kw">=</span> <span class="no">ftype</span>,
                  <span class="kw">trt</span> <span class="kw">=</span> <span class="no">trt</span>, <span class="kw">adjustVars</span> <span class="kw">=</span> <span class="no">adjustVars</span>,
                  <span class="kw">SL.trt</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                  <span class="kw">SL.ftime</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                  <span class="kw">SL.ctime</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                  <span class="kw">method</span> <span class="kw">=</span> <span class="st">"hazard"</span>, <span class="kw">t0</span> <span class="kw">=</span> <span class="no">t_0</span>)
<span class="no">fit10</span></pre></body></html></div>
<pre><code>## $est
##          [,1]
## 0 1 0.4568904
## 1 1 0.6058038
## 0 2 0.2902240
## 1 2 0.2649739
## 
## $var
##               0 1           1 1           0 2           1 2
## 0 1  2.602789e-03 -1.316328e-03  4.805231e-05  5.155684e-05
## 1 1 -1.316328e-03  2.013086e-03 -9.997808e-06  5.809581e-05
## 0 2  4.805231e-05 -9.997808e-06  3.042096e-03 -2.158941e-03
## 1 2  5.155684e-05  5.809581e-05 -2.158941e-03  2.520370e-03</code></pre>
<p>As with the iterated-mean based TMLE, we can obtain estimates of cumulative incidence of only certain failure types (via <code>ftypeOfInterest</code>); however, this does not necessarily result in faster computation, as it did in the case above. In situations where the convergence of the algorithm is an issue, it may be useful to invoke multiple calls to <code>survtmle</code> with singular <code>ftypeOfInterest</code>. If such convergence issues arise, please report them as <a href="https://github.com/benkeser/survtmle/issues">GitHub issues</a> or contact us at <a href="mailto:benkeser@emory.edu">benkeser@emory.edu</a>.</p>
</div>
</div>
</div>
<div id="estimation-in-bounded-models" class="section level2">
<h2 class="hasAnchor">
<a href="#estimation-in-bounded-models" class="anchor"></a>Estimation in bounded models</h2>
<p>In certain situations, we have knowledge that the incidence of an event is bounded below/above for every strata in the population. It is possible to incorporate these bounds into the TMLE estimation procedure to ensure that any resulting estimate of cumulative incidence is compatible with these bounds. Please refer to <span class="citation">Benkeser, Carone, and Gilbert (2017)</span> for more on bounded TMLEs and their potential benefits.</p>
<p>Bounds can be passed to <code>survtmle</code> by creating a <code>data.frame</code> that contains columns with specific names. In particular, there should be a column named <code>"t"</code>. There should additionally be columns for the lower and upper bound for each type of failure. For example if there is only one type of failure (<code>ftype = 1</code> or <code>ftype = 0</code>) then the bounds <code>data.frame</code> can contain columns <code>"l1"</code>, and <code>"u1"</code> denote the lower and upper bounds, respectively, on the iterated conditional mean (for <code>method = "mean"</code>) or the conditional hazard function (for <code>method = "hazard"</code>). If there are two types of failure (<code>ftype = 1</code>, <code>ftype = 2</code>, or <code>ftype = 0</code>) then there can additionally be columns <code>"l2"</code> and <code>"u2"</code> denoting the lower and upper bounds, respectively, on the iterated conditional mean for type two failures (for <code>method = "mean"</code>) or the conditional cause-specific hazard function for type two failures (for <code>method = "hazard"</code>).</p>
<p>Here is a simple example.</p>
<div class="sourceCode" id="cb35"><html><body><pre class="r"><span class="no">bf1</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(<span class="kw">t</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq_len</a></span>(<span class="no">t_0</span>), <span class="kw">l1</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="fl">0.01</span>, <span class="no">t_0</span>), <span class="kw">u1</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="fl">0.99</span>, <span class="no">t_0</span>))
<span class="no">bf1</span></pre></body></html></div>
<pre><code>##   t   l1   u1
## 1 1 0.01 0.99
## 2 2 0.01 0.99
## 3 3 0.01 0.99
## 4 4 0.01 0.99
## 5 5 0.01 0.99
## 6 6 0.01 0.99</code></pre>
<p>Now that we have specified our bounds, we can invoke <code>survtmle</code> repeating our first example (“Fit 1”), but now restricting the iterated conditional means to follow the bounds specified above.</p>
<div class="sourceCode" id="cb37"><html><body><pre class="r"><span class="co"># Fit 11: Fit 2, but now specifying bounds on the iterated conditional means</span>
<span class="no">fit11</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="kw">ftime</span> <span class="kw">=</span> <span class="no">ftime</span>, <span class="kw">ftype</span> <span class="kw">=</span> <span class="no">ftype</span>,
                 <span class="kw">trt</span> <span class="kw">=</span> <span class="no">trt</span>, <span class="kw">adjustVars</span> <span class="kw">=</span> <span class="no">adjustVars</span>,
                 <span class="kw">glm.trt</span> <span class="kw">=</span> <span class="st">"W1 + W2"</span>,
                 <span class="kw">glm.ftime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="kw">glm.ctime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="kw">method</span> <span class="kw">=</span> <span class="st">"mean"</span>, <span class="kw">t0</span> <span class="kw">=</span> <span class="no">t_0</span>,
                 <span class="kw">bounds</span> <span class="kw">=</span> <span class="no">bf1</span>)
<span class="no">fit11</span></pre></body></html></div>
<pre><code>## $est
##          [,1]
## 0 1 0.4230616
## 1 1 0.6028624
## 0 2 0.2517208
## 1 2 0.2967996
## 
## $var
##               0 1           1 1           0 2           1 2
## 0 1  3.517185e-03  2.107583e-05 -1.688921e-03  5.968034e-05
## 1 1  2.107583e-05  3.228259e-03 -2.394680e-05 -2.382745e-03
## 0 2 -1.688921e-03 -2.394680e-05  2.544824e-03  7.730107e-05
## 1 2  5.968034e-05 -2.382745e-03  7.730107e-05  2.615547e-03</code></pre>
<p>When there are multiple failure types of interest, we can still provide bounds for the iterated conditional means (or the conditional hazard function, whichever is appropriate based on our specification of the <code>method</code> argument).</p>
<div class="sourceCode" id="cb39"><html><body><pre class="r"><span class="co"># need to make a data.frame of bounds in proper format two types of failure that</span>
<span class="co"># are labeled with ftype = 1 and ftype = 2, so bounds should have columns 't',</span>
<span class="co"># 'l1', 'u1', 'l2', and 'u2'.</span>
<span class="no">bf2</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(<span class="kw">t</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq_len</a></span>(<span class="no">t_0</span>),
                  <span class="kw">l1</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="fl">0.01</span>, <span class="no">t_0</span>), <span class="kw">u1</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="fl">0.99</span>, <span class="no">t_0</span>),
                  <span class="kw">l2</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="fl">0.02</span>, <span class="no">t_0</span>), <span class="kw">u2</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="fl">0.99</span>, <span class="no">t_0</span>)
                 )
<span class="no">bf2</span></pre></body></html></div>
<pre><code>##   t   l1   u1   l2   u2
## 1 1 0.01 0.99 0.02 0.99
## 2 2 0.01 0.99 0.02 0.99
## 3 3 0.01 0.99 0.02 0.99
## 4 4 0.01 0.99 0.02 0.99
## 5 5 0.01 0.99 0.02 0.99
## 6 6 0.01 0.99 0.02 0.99</code></pre>
<p>Now, we invoke <code>survtmle</code>, passing in the specified bounds using the appropriate argument:</p>
<div class="sourceCode" id="cb41"><html><body><pre class="r"><span class="co"># Fit 12: same as Fit 5 above, but now include bounds</span>
<span class="no">fit12</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="kw">ftime</span> <span class="kw">=</span> <span class="no">ftime</span>, <span class="kw">ftype</span> <span class="kw">=</span> <span class="no">ftype</span>,
                  <span class="kw">trt</span> <span class="kw">=</span> <span class="no">trt</span>, <span class="kw">adjustVars</span> <span class="kw">=</span> <span class="no">adjustVars</span>,
                  <span class="kw">glm.trt</span> <span class="kw">=</span> <span class="st">"W1 + W2"</span>,
                  <span class="kw">glm.ftime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2"</span>,
                  <span class="kw">glm.ctime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2"</span>,
                  <span class="kw">method</span> <span class="kw">=</span> <span class="st">"mean"</span>, <span class="kw">t0</span> <span class="kw">=</span> <span class="no">t_0</span>,
                  <span class="kw">bounds</span> <span class="kw">=</span> <span class="no">bf2</span>)
<span class="no">fit12</span></pre></body></html></div>
<pre><code>## $est
##          [,1]
## 0 1 0.4230616
## 1 1 0.6028624
## 0 2 0.2524880
## 1 2 0.2995662
## 
## $var
##               0 1           1 1           0 2           1 2
## 0 1  3.517185e-03  2.107583e-05 -1.695712e-03  6.011004e-05
## 1 1  2.107583e-05  3.228259e-03 -2.426839e-05 -2.393105e-03
## 0 2 -1.695712e-03 -2.426839e-05  2.554253e-03  7.964879e-05
## 1 2  6.011004e-05 -2.393105e-03  7.964879e-05  2.640192e-03</code></pre>
<p><strong>Remark 1:</strong> Please see the discussion in <span class="citation">Benkeser, Carone, and Gilbert (2017)</span> on how to select bounds for these procedures. Note that poorly chosen bounds can lead to instability in the estimation procedure.</p>
<p><strong>Remark 2:</strong> While it is theoretically possible to use super learner to perform bounded estimation, many of the implemented algorithms are not currently designed to respect bounds. Nevertheless, it is possible to write one’s own algorithms to incorporate such bounds. However, for the sake of stability, we have restricted the bounded implementation to <code>glm</code> based covariate-adjustment.</p>
<hr>
</div>
<div id="utility-functions" class="section level2">
<h2 class="hasAnchor">
<a href="#utility-functions" class="anchor"></a>Utility functions</h2>
<div id="estimating-cumulative-incidence-curves" class="section level3">
<h3 class="hasAnchor">
<a href="#estimating-cumulative-incidence-curves" class="anchor"></a>Estimating cumulative incidence curves</h3>
<p>The <code>survtmle</code> function provides the function <code>timepoints</code> to compute the estimated cumulative incidence over multiple timepoints. This function is invoked after an initial call to <code>survtmle</code> with option <code>returnModels = TRUE</code>. By setting this option, the <code>timepoints</code> function is able to recycle fits for the conditional treatment probability, censoring distribution, and, in the case of <code>method = "hazard"</code>, the hazard fits. Thus, invoking <code>timepoints</code> is faster than making repeated calls to <code>survtmle</code> with different <code>t0</code>.</p>
<p>There is some subtlety involved to properly leveraging this facility. Recall that the censoring distribution fit (and cause-specific hazard fit) pools over all time points. Thus, in order to most efficiently use <code>timepoints</code>, the initial call to <code>survtmle</code> should be made setting option <code>t0</code> equal to the final time point at which one wants estimates of cumulative incidence. This allows these hazard fitting procedures to utilize all of the data to estimate the conditional hazard function.</p>
<p>We demonstrate the use of <code>timepoints</code> below based on the following simulated data.</p>
<div class="sourceCode" id="cb43"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span>(<span class="fl">1234</span>)
<span class="no">n</span> <span class="kw">&lt;-</span> <span class="fl">200</span>
<span class="no">t_0</span> <span class="kw">&lt;-</span> <span class="fl">6</span>
<span class="no">trt</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">rbinom</a></span>(<span class="no">n</span>, <span class="fl">1</span>, <span class="fl">0.5</span>)
<span class="no">adjustVars</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(<span class="kw">W1</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span>(<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="no">n</span>)), <span class="kw">W2</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span>(<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="no">n</span>, <span class="fl">0</span>, <span class="fl">2</span>)))
<span class="no">ftime</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span>(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="no">n</span>, <span class="fl">1</span>, <span class="fl">4</span>) - <span class="no">trt</span> + <span class="no">adjustVars</span>$<span class="no">W1</span> + <span class="no">adjustVars</span>$<span class="no">W2</span>)
<span class="no">ftype</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span>(<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="no">n</span>, <span class="fl">0</span>, <span class="fl">1</span>))</pre></body></html></div>
<p>Imagine that we would like cumulative incidence estimates at times <code><a href="https://rdrr.io/r/base/seq.html">seq_len(t_0)</a></code> based on <code>fit2</code> above (mean-based TMLE using glm covariate adjustment). However, note that when we originally called <code>fit2</code> the option <code>returnModels</code> was set to its default value <code>FALSE</code>. Thus, we must refit this object setting the function to return the model fits.</p>
<div class="sourceCode" id="cb44"><html><body><pre class="r"><span class="co"># Refit fit 2 returning models</span>
<span class="no">fit2_rm</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="kw">ftime</span> <span class="kw">=</span> <span class="no">ftime</span>, <span class="kw">ftype</span> <span class="kw">=</span> <span class="no">ftype</span>,
                 <span class="kw">trt</span> <span class="kw">=</span> <span class="no">trt</span>, <span class="kw">adjustVars</span> <span class="kw">=</span> <span class="no">adjustVars</span>,
                 <span class="kw">glm.trt</span> <span class="kw">=</span> <span class="st">"W1 + W2"</span>,
                 <span class="kw">glm.ctime</span> <span class="kw">=</span> <span class="st">"W1 + trt + t + I(t^2)"</span>,
                 <span class="kw">glm.ftime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="kw">method</span> <span class="kw">=</span> <span class="st">"mean"</span>, <span class="kw">t0</span> <span class="kw">=</span> <span class="no">t_0</span>,
                 <span class="kw">returnModels</span> <span class="kw">=</span> <span class="fl">TRUE</span>)
<span class="no">fit2_rm</span></pre></body></html></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5657950
## 1 1 0.7411658
## 
## $var
##              0 1          1 1
## 0 1 0.0029470633 0.0002170549
## 1 1 0.0002170549 0.0016411250</code></pre>
<p>Now we can call <code>timepoints</code> to return estimates of cumulative incidence at each time <code><a href="https://rdrr.io/r/base/seq.html">seq_len(t_0)</a></code>.</p>
<div class="sourceCode" id="cb46"><html><body><pre class="r"><span class="no">tp.fit2</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/timepoints.html">timepoints</a></span>(<span class="no">fit2_rm</span>, <span class="kw">times</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq_len</a></span>(<span class="no">t_0</span>))
<span class="co"># print the object</span>
<span class="no">tp.fit2</span></pre></body></html></div>
<pre><code>## $est
##   t1         t2         t3        t4        t5        t6
## 1  0 0.01616033 0.08976902 0.1610393 0.3918143 0.5657950
## 2  0 0.07450353 0.18960097 0.4279096 0.5784108 0.7411658
## 
## $var
##   t1           t2           t3          t4          t5          t6
## 1 NA 0.0001427635 0.0007369614 0.001131293 0.002291745 0.002947063
## 2 NA 0.0006741195 0.0015590438 0.002276863 0.002277642 0.001641125</code></pre>
<p>Internally, <code>timepoints</code> is making calls to <code>survtmle</code>, but is passing in the fitted treatment and censoring fits from <code>fit2_rm$trtMod</code> and <code>fit2_rm$ctimeMod</code>. However, for <code>method = "mean"</code> the function is still fitting the iterated means separately for each time required by the call to <code>timepoints</code>. Thus, the call to <code>timepoints</code> may be quite slow if <code>method = "mean"</code>, <code>SL.ftime</code> is specified (as opposed to <code>glm.ftime</code>), and/or many times are passed in via <code>times</code>. Future implementations may attempt to avoid this extra model fitting. For now, if many times are required, we recommend using <code>method = "hazard"</code>, which is able to recycle all of the model fits. Below is an example of this.</p>
<div class="sourceCode" id="cb48"><html><body><pre class="r"><span class="co"># Refit Fit 4, setting returnModels=TRUE this time...</span>
<span class="no">fit4_rm</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="kw">ftime</span> <span class="kw">=</span> <span class="no">ftime</span>, <span class="kw">ftype</span> <span class="kw">=</span> <span class="no">ftype</span>,
                    <span class="kw">trt</span> <span class="kw">=</span> <span class="no">trt</span>, <span class="kw">adjustVars</span> <span class="kw">=</span> <span class="no">adjustVars</span>,
                    <span class="kw">glm.trt</span> <span class="kw">=</span> <span class="st">"W1 + W2"</span>,
                    <span class="kw">glm.ftime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2 + t + I(t^2)"</span>,
                    <span class="kw">glm.ctime</span> <span class="kw">=</span> <span class="st">"trt + W1 + W2*t"</span>,
                    <span class="kw">method</span> <span class="kw">=</span> <span class="st">"hazard"</span>, <span class="kw">t0</span> <span class="kw">=</span> <span class="no">t_0</span>,
                    <span class="kw">returnModels</span> <span class="kw">=</span> <span class="fl">TRUE</span>)
<span class="co"># call timepoints based on this fit</span>
<span class="no">tp.fit4</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/timepoints.html">timepoints</a></span>(<span class="no">fit4_rm</span>, <span class="kw">times</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq_len</a></span>(<span class="no">t_0</span>))
<span class="co"># print the object</span>
<span class="no">tp.fit4</span></pre></body></html></div>
<pre><code>## $est
##   t1         t2         t3        t4        t5        t6
## 1  0 0.03457851 0.09883419 0.2215276 0.3966049 0.5864610
## 2  0 0.07816849 0.20103813 0.3901823 0.6014791 0.7788141
## 
## $var
##   t1           t2          t3          t4          t5          t6
## 1 NA 0.0001481315 0.000799149 0.001273434 0.002852316 0.002813856
## 2 NA 0.0007267294 0.001906479 0.003232722 0.003374974 0.001813312</code></pre>
<p>There is a plotting method available for <code>timepoints</code> to plot cumulative incidence over time in each treatment group and for each failure type.</p>
<div class="sourceCode" id="cb50"><html><body><pre class="r"><span class="co"># plot raw cumulative incidence</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.html">plot</a></span>(<span class="no">tp.fit4</span>, <span class="kw">type</span> <span class="kw">=</span> <span class="st">"raw"</span>)</pre></body></html></div>
<p><img src="survtmle_intro_files/figure-html/unnamed-chunk-5-1.png" width="700"></p>
<p>Because the cumulative incidence function is being invoked pointwise, it is possible that the resulting curve is not monotone. However, it is possible to show that projecting this curve onto a monotone function via isotonic regression results in an estimate with identical asymptotic properties to the pointwise estimate. Therefore, we additionally provide an option <code>type = "iso"</code> (the default) that provides these smoothed curves.</p>
<div class="sourceCode" id="cb51"><html><body><pre class="r"><span class="co"># plot smoothed cumulative incidence</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.html">plot</a></span>(<span class="no">tp.fit4</span>)</pre></body></html></div>
</div>
</div>
<div id="section" class="section level2">
<h2 class="hasAnchor">
<a href="#section" class="anchor"></a><img src="survtmle_intro_files/figure-html/unnamed-chunk-6-1.png" width="700">
</h2>
</div>
<div id="session-information" class="section level2">
<h2 class="hasAnchor">
<a href="#session-information" class="anchor"></a>Session Information</h2>
<pre><code>## R version 3.6.3 (2020-02-29)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 18.04.4 LTS
## 
## Matrix products: default
## BLAS:   /usr/lib/x86_64-linux-gnu/openblas/libblas.so.3
## LAPACK: /usr/lib/x86_64-linux-gnu/libopenblasp-r0.2.20.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] nnls_1.4       survtmle_1.1.3 tibble_3.0.1  
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_1.0.4.6        plyr_1.8.6          pillar_1.4.4       
##  [4] compiler_3.6.3      tools_3.6.3         digest_0.6.25      
##  [7] evaluate_0.14       memoise_1.1.0       lifecycle_0.2.0    
## [10] gtable_0.3.0        lattice_0.20-41     pkgconfig_2.0.3    
## [13] rlang_0.4.6         Matrix_1.2-18       cli_2.0.2          
## [16] ggsci_2.9           yaml_2.2.1          speedglm_0.3-2     
## [19] pkgdown_1.5.1       xfun_0.14           SuperLearner_2.0-26
## [22] stringr_1.4.0       dplyr_1.0.0         knitr_1.28         
## [25] desc_1.2.0          generics_0.0.2      fs_1.4.1           
## [28] vctrs_0.3.1         rprojroot_1.3-2     grid_3.6.3         
## [31] tidyselect_1.1.0    glue_1.4.1          R6_2.4.1           
## [34] fansi_0.4.1         rmarkdown_2.2       farver_2.0.3       
## [37] tidyr_1.1.0         purrr_0.3.4         ggplot2_3.3.1      
## [40] magrittr_1.5        backports_1.1.7     scales_1.1.1       
## [43] ellipsis_0.3.1      htmltools_0.4.0     MASS_7.3-51.6      
## [46] assertthat_0.2.1    colorspace_1.4-1    labeling_0.3       
## [49] utf8_1.1.4          stringi_1.4.6       munsell_0.5.0      
## [52] crayon_1.3.4</code></pre>
<hr>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h2>
<div id="refs" class="references">
<div id="ref-bang2005doubly">
<p>Bang, Heejung, and James M Robins. 2005. “Doubly Robust Estimation in Missing Data and Causal Inference Models.” <em>Biometrics</em> 61 (4). Wiley Online Library: 962–73. <a href="https://doi.org/10.1111/j.1541-0420.2005.00377.x" class="uri">https://doi.org/10.1111/j.1541-0420.2005.00377.x</a>.</p>
</div>
<div id="ref-benkeser2017improved">
<p>Benkeser, David, Marco Carone, and Peter B Gilbert. 2017. “Improved Estimation of the Cumulative Incidence of Rare Outcomes.” <em>Statistics in Medicine</em>. Wiley Online Library. <a href="https://doi.org/10.1002/sim.7337" class="uri">https://doi.org/10.1002/sim.7337</a>.</p>
</div>
<div id="ref-breiman1996stacked">
<p>Breiman, Leo. 1996. “Stacked Regressions.” <em>Machine Learning</em> 24 (1). Springer: 49–64. <a href="https://doi.org/10.1007/BF00117832" class="uri">https://doi.org/10.1007/BF00117832</a>.</p>
</div>
<div id="ref-vdlgruber:2012:ijb">
<p>Laan, Mark J van der, and Susan Gruber. 2012. “Targeted Minimum Loss Based Estimation of Causal Effects of Multiple Time Point Interventions.” Journal Article. <em>The International Journal of Biostatistics</em> 8 (1): 1–34. <a href="https://doi.org/10.1515/1557-4679.1370" class="uri">https://doi.org/10.1515/1557-4679.1370</a>.</p>
</div>
<div id="ref-vdlpolley:2007:statappgenetics">
<p>Laan, Mark J van der, Eric C Polley, and Alan E Hubbard. 2007. “Super Learner.” Journal Article. <em>Statistical Applications in Genetics and Molecular Biology</em> 6 (1): 1–23. <a href="https://doi.org/10.2202/1544-6115.1309" class="uri">https://doi.org/10.2202/1544-6115.1309</a>.</p>
</div>
<div id="ref-moore2009increasing">
<p>Moore, Kelly L, and Mark J van der Laan. 2009. “Increasing Power in Randomized Trials with Right Censored Outcomes Through Covariate Adjustment.” <em>Journal of Biopharmaceutical Statistics</em> 19 (6). Taylor &amp; Francis: 1099–1131. <a href="https://doi.org/10.1080/10543400903243017" class="uri">https://doi.org/10.1080/10543400903243017</a>.</p>
</div>
<div id="ref-robins1999ltmle">
<p>Robins, Jamie M. 1999. “Robust Estimation in Sequentially Ignorable Missing Data and Causal Inference Models.” Proceedings of the American Statistical Association Section on Bayesian Statistical Science. <a href="http://www.biostat.harvard.edu/robins/jsaprocpat1.pdf" class="uri">http://www.biostat.harvard.edu/robins/jsaprocpat1.pdf</a>.</p>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by David Benkeser, Nima Hejazi.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.5.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
