<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Targeted Learning for Survival Analysis with Competing Risks • survtmle</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">survtmle</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="..//index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/survtmle_intro.html">Targeted Learning for Survival Analysis with Competing Risks</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/benkeser/survtmle">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Targeted Learning for Survival Analysis with Competing Risks</h1>
                        <h4 class="author">David Benkeser &amp; Nima Hejazi</h4>
            
            <h4 class="date">2017-07-11</h4>
          </div>

    
    
<div class="contents">
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p>The <code>survtmle</code> package is designed to use targeted minimum loss-based estimation (TMLE) to compute covariate-adjusted marginal cumulative incidence estimates in right-censored survival settings with and without competing risks. In order to allow flexibility of modeling, the estimates can leverage ensemble machine learning via the <a href="https://cran.r-project.org/web/packages/SuperLearner/index.html"><code>SuperLearner</code></a> package.</p>
<hr>
</div>
<div id="simulation" class="section level2">
<h2 class="hasAnchor">
<a href="#simulation" class="anchor"></a>Simulation</h2>
<p>We’ll proceed by examining the use of <code>survtmle</code> in a variety of simple examples. First, let’s load the package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(survtmle)</code></pre></div>
<pre><code>## survtmle: Targeted Learning for Survival Analysis</code></pre>
<pre><code>## Version: 0.1.2</code></pre>
<p>Before diving into how we might harness the machinery of the <code>survtmle</code> package, we’ll simulate a simple data set with a single failure type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1234</span>)
n &lt;-<span class="st"> </span><span class="dv">200</span>
t_<span class="dv">0</span> &lt;-<span class="st"> </span><span class="dv">6</span>  <span class="co"># time point at which to return cumulative incidence estimates</span>
trt &lt;-<span class="st"> </span><span class="kw">rbinom</span>(n, <span class="dv">1</span>, <span class="fl">0.5</span>)
adjustVars &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">W1 =</span> <span class="kw">round</span>(<span class="kw">runif</span>(n)), <span class="dt">W2 =</span> <span class="kw">round</span>(<span class="kw">runif</span>(n, <span class="dv">0</span>, <span class="dv">2</span>)))
ftime &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">runif</span>(n, <span class="dv">1</span>, <span class="dv">4</span>) <span class="op">-</span><span class="st"> </span>trt <span class="op">+</span><span class="st"> </span>adjustVars<span class="op">$</span>W1 <span class="op">+</span><span class="st"> </span>adjustVars<span class="op">$</span>W2)
ftype &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="kw">runif</span>(n, <span class="dv">0</span>, <span class="dv">1</span>))</code></pre></div>
<p>The very simple data structure that we simulated (the <code>tibble</code>, <code>d</code>) contains a set of adjustment (or “baseline”) covariates (<code>adjustVars</code>); a treatment variable (<code>trt</code>) denoting the intervention of interest; a failure time (<code>ftime</code>), a simple function of the treatment and adjustment variables with added noise (a Uniform random variable); and a failure type (<code>ftype</code>), merely denoting an observed cause of failure, unrelated to the failure time. In all following examples, we will estimate cumulative incidence for each of the groups at an arbitrary time point (<code>t_0</code>).</p>
<p>Let’s examine just the first few rows of the observed data set:</p>
<pre><code>## # A tibble: 200 x 5
##    ftype ftime   trt    W1    W2
##    &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1     0     5     0     1     1
##  2     1     4     1     1     1
##  3     1     4     1     0     2
##  4     0     6     1     1     2
##  5     0     4     1     1     1
##  6     1     3     1     1     0
##  7     0     7     0     0     2
##  8     0     3     0     0     0
##  9     1     4     1     0     1
## 10     0     4     1     1     1
## # ... with 190 more rows</code></pre>
<hr>
</div>
<div id="using-the-g-computation-method" class="section level2">
<h2 class="hasAnchor">
<a href="#using-the-g-computation-method" class="anchor"></a>Using the G-computation method</h2>
<p>We are now ready to make use of <code>survtmle</code> to flexibly assess the differences in survival between the groups designated by the failure type variable above.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Fit 1: GLM estimators for treatment, censoring, and failure w/ "mean" method</span>
fit1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="dt">ftime =</span> ftime, <span class="dt">ftype =</span> ftype,
                 <span class="dt">trt =</span> trt, <span class="dt">adjustVars =</span> adjustVars,
                 <span class="dt">glm.trt =</span> <span class="st">"W1 + W2"</span>,
                 <span class="dt">glm.ftime =</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="dt">glm.ctime =</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="dt">method =</span> <span class="st">"mean"</span>, <span class="dt">t0 =</span> t_<span class="dv">0</span>)
fit1</code></pre></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5660495
## 1 1 0.7412935
## 
## $var
##              0 1          1 1
## 0 1 0.0042149062 0.0002205963
## 1 1 0.0002205963 0.0023100990</code></pre>
<p>Above, we invoke the eponymous <code>survtmle</code> function to estimate the differences in survival between the two groups defined by the failure type. In this very simple setup, we only make use of GLMs, estimating the treatment mechanism (via the <code>trt</code> argument) as a linear function of the adjustment variables (<code>W1</code> and <code>W2</code>) and both the failure time and censoring time as linear functions of the treatment and adjustment covariates. Additionally, we specify the <code>mean</code> method to use a targeted minimum loss-based estimator based on the G-computation formula of <span class="citation">Bang and Robins (2005)</span>.</p>
<p>While we can certainly use GLMs to model our treatment mechanism as well as our failure and censoring times (as we did above), a major flexibility afforded by <code>survtmle</code> is the leveraging of the <code>SuperLearner</code> ensemble learning algorithm to estimate these quantities in a nonparametric manner.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Fit 2: SuperLearner estimators for failure and censoring, alongside empirical</span>
<span class="co">#        estimators for treatment (the default) using the "mean" method</span>
fit2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="dt">ftime =</span> ftime, <span class="dt">ftype =</span> ftype,
                 <span class="dt">trt =</span> trt, <span class="dt">adjustVars =</span> adjustVars,
                 <span class="dt">SL.ftime =</span> <span class="kw">c</span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                 <span class="dt">SL.ctime =</span> <span class="kw">c</span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                 <span class="dt">method =</span> <span class="st">"mean"</span>, <span class="dt">t0 =</span> t_<span class="dv">0</span>)</code></pre></div>
<pre><code>## Warning in checkInputs(ftime = ftime, ftype = ftype, trt = trt, t0 = t0, :
## glm.trt and SL.trt not specified. Proceeding with glm.trt = '1'</code></pre>
<pre><code>## Loading required package: nnls</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fit2</code></pre></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5486394
## 1 1 0.6962562
## 
## $var
##              0 1          1 1
## 0 1 0.0029392806 0.0001605295
## 1 1 0.0001605295 0.0018713076</code></pre>
<p>In the above formulation, we invoke the <code>survtmle</code> function in largely the same manner as before, the principal difference being that we now provide a library of estimation algorithms to be used in fitting the failure and censoring, as opposed to specifying a functional form as was necessary with GLMs. In this case, the <code>SuperLearner</code> ensemble learning algorithm is used to combine the algorithms in the specified library, generating predictions that are “optimal” based on an appropriate loss function. Essentially, the SuperLearner algorithm performs stacked regression <span class="citation">(Breiman 1996)</span> using a set of specified nonparametric regression procedures (i.e., machine learning algorithms). The interested reader is invited to consult <span class="citation">van der Laan, Polley, and Hubbard (2007)</span> for details about the SuperLearner algorithm as well as <span class="citation">van der Laan and Rose (2011)</span> and <span class="citation">van der Laan and Rose (2017)</span> for a treatment of the central role this algorithm plays in targeted learning.</p>
<hr>
</div>
<div id="using-the-method-of-cause-specific-hazards" class="section level2">
<h2 class="hasAnchor">
<a href="#using-the-method-of-cause-specific-hazards" class="anchor"></a>Using the method of cause-specific hazards</h2>
<p>When using <code>survtmle</code>, we need not rely on TMLEs that invoke the G-computation formula as we did when invoking <code>method = "mean"</code> above. Rather, <code>survtmle</code> also contains a <code>method = "harzard"</code> specification, which allows the estimates to be obtained by way of an iterative algorithm using the cause-specific hazard functions. The current implementation of this particular specification has no guarantee of convergence in finite samples, though it may eventually be replaced by a closed-form version.</p>
<p>We can invoke the hazard-specific estimation procedure with GLMs as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Fit 3: GLM estimators for treatment, censoring, and failure w/ "hazard" method</span>
fit3 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="dt">ftime =</span> ftime, <span class="dt">ftype =</span> ftype,
                 <span class="dt">trt =</span> trt, <span class="dt">adjustVars =</span> adjustVars,
                 <span class="dt">glm.trt =</span> <span class="st">"W1 + W2"</span>,
                 <span class="dt">glm.ftime =</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="dt">glm.ctime =</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="dt">method =</span> <span class="st">"hazard"</span>, <span class="dt">t0 =</span> t_<span class="dv">0</span>)
fit3</code></pre></div>
<pre><code>## $est
##          [,1]
## 0 1 0.6011438
## 1 1 0.7696831
## 
## $var
##              0 1          1 1
## 0 1 0.0049822981 0.0001630668
## 1 1 0.0001630668 0.0031109841</code></pre>
<p>The above is quite similar to “Fit 1” – our first example using GLM-based estimators for the treatment mechanism as well as the failure and censoring times. The only difference here comes from invoking <code>method = "hazard"</code> instead of <code>method = "mean"</code>, which, as noted above, relies on the cause-specific hazard for estimation, rather than the G-computation formula.</p>
<p>We can also use the method of cause-specific hazards with the <code>SuperLearner</code> algorithm to obtain our estimates nonparametrically – without being forced to specify constrained functional forms using GLMs. Let’s try that out now:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Fit 4: SuperLearner estimators for failure and censoring, alongside empirical</span>
<span class="co">#        estimators for treatment (the default) using the "hazard" method</span>
fit4 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="dt">ftime =</span> ftime, <span class="dt">ftype =</span> ftype,
                 <span class="dt">trt =</span> trt, <span class="dt">adjustVars =</span> adjustVars,
                 <span class="dt">SL.ftime =</span> <span class="kw">c</span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                 <span class="dt">SL.ctime =</span> <span class="kw">c</span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                 <span class="dt">method =</span> <span class="st">"hazard"</span>, <span class="dt">t0 =</span> t_<span class="dv">0</span>)</code></pre></div>
<pre><code>## Warning in checkInputs(ftime = ftime, ftype = ftype, trt = trt, t0 = t0, :
## glm.trt and SL.trt not specified. Proceeding with glm.trt = '1'</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fit4</code></pre></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5854866
## 1 1 0.7570647
## 
## $var
##              0 1          1 1
## 0 1 0.0027030819 0.0002137453
## 1 1 0.0002137453 0.0020991797</code></pre>
<p>Just as in the second example (“Fit 2” in the previous section), we rely on the <code>SuperLearner</code> algorithm to flexibly model the failure and censoring times, passing in a library of nonparametric regression procedures to be stacked to produce optimal predictions. Unlike in that example, we now invoke the method of cause-specific hazards (<code>method = "hazard"</code>).</p>
<hr>
</div>
<div id="bounded-tmles" class="section level2">
<h2 class="hasAnchor">
<a href="#bounded-tmles" class="anchor"></a>Bounded TMLEs</h2>
<p>In the preceding two sections, we examined the simplest ways by which <code>survtmle</code> can be invoked. In the four examples contained therein, we saw two major choies left to the user: (1) whether to rely on GLMs, which require the specification of functional forms for several quantities of interest, or to use <code>SuperLearner</code> to estimate such quantities nonparametrically using stacked regression; and (2) whether to rely on TMLEs using the G-computation formula or to obtain estimates by using the method of cause-specific hazards.</p>
<p>Now, we will examine several complex examples, with an eye towards demonstrating the advanced functionality that <code>survtmle</code> provides.</p>
<p>…Background on bounded TMLEs…</p>
<p>We can create bounded TMLEs by specifying a <code>data.frame</code> that contains columns denoted “t”, “l1”, and “u1”, which specify the set of times of interest, as well as lower and upper bounds, respectively, on the iterated conditional mean (for <code>method = "mean")</code> or the conditional hazard function (for <code>method = "hazard"</code>).</p>
<p>Let us specify the <code>data.frame</code> of bounds for a simple example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bf1 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">t =</span> <span class="kw">seq_len</span>(t_<span class="dv">0</span>), <span class="dt">l1 =</span> <span class="kw">rep</span>(<span class="fl">0.01</span>, t_<span class="dv">0</span>), <span class="dt">u1 =</span> <span class="kw">rep</span>(<span class="fl">0.99</span>, t_<span class="dv">0</span>))
bf1</code></pre></div>
<pre><code>##   t   l1   u1
## 1 1 0.01 0.99
## 2 2 0.01 0.99
## 3 3 0.01 0.99
## 4 4 0.01 0.99
## 5 5 0.01 0.99
## 6 6 0.01 0.99</code></pre>
<p>The above <code>data.frame</code> contains the lower and upper bounds (“l1” and “u1”, respectively) to be used with the conditional mean or hazard (whichever we choose to invoke with <code>survtmle</code>) for the failure type (<code>ftype</code>) of interest, denoted “1”. Note that bounds must be provided for each failure type of interest (here we only have one such failure type, so we need only provide as many bounds).</p>
<p>Now that we have specified our bounds, we can invoke <code>survtmle</code>. We’ll do this by essentially repeating our first example (“Fit 1”), using GLM estimators. The major difference here is that we restrict the iterated conditional mean to follow the bounds specified above.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Fit 5: Fit 1, but now specifying bounds on the iterated conditional means</span>
fit5 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="dt">ftime =</span> ftime, <span class="dt">ftype =</span> ftype,
                 <span class="dt">trt =</span> trt, <span class="dt">adjustVars =</span> adjustVars,
                 <span class="dt">glm.trt =</span> <span class="st">"W1 + W2"</span>,
                 <span class="dt">glm.ftime =</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="dt">glm.ctime =</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="dt">method =</span> <span class="st">"mean"</span>, <span class="dt">t0 =</span> t_<span class="dv">0</span>,
                 <span class="dt">bounds =</span> bf1)
fit5</code></pre></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5658378
## 1 1 0.7413279
## 
## $var
##              0 1          1 1
## 0 1 0.0042119035 0.0002210213
## 1 1 0.0002210213 0.0023097007</code></pre>
<p>The substantive difference here is that, as noted above, we have bounded our estimate of the iterated conditional mean for the failure type of interest. While we have demonstrated this using a TMLE based on the G-computation formula <code>method = "mean"</code>, the same procedure could be applied when invoking the estimation procedure using the method of cause-specific hazards.</p>
<hr>
</div>
<div id="assessing-multiple-failure-types" class="section level2">
<h2 class="hasAnchor">
<a href="#assessing-multiple-failure-types" class="anchor"></a>Assessing Multiple Failure Types</h2>
<p>In all of the preceding examples, we have restricted our attention to rather simplistic cases – those where there is only a single failure type of interest. Now, let us consider more realistic (and complex!) scenarios where we observe multiple failure types.</p>
<p>We’ll start by simulating a data set with multiple failure types:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1234</span>)
n &lt;-<span class="st"> </span><span class="dv">100</span>
t_<span class="dv">0</span> &lt;-<span class="st"> </span><span class="dv">6</span>
trt &lt;-<span class="st"> </span><span class="kw">rbinom</span>(n, <span class="dv">1</span>, <span class="fl">0.5</span>)
adjustVars &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">W1 =</span> <span class="kw">round</span>(<span class="kw">runif</span>(n)), <span class="dt">W2 =</span> <span class="kw">round</span>(<span class="kw">runif</span>(n, <span class="dv">0</span>, <span class="dv">2</span>)))
ftime &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">runif</span>(n, <span class="dv">1</span>, <span class="dv">4</span>) <span class="op">-</span><span class="st"> </span>trt <span class="op">+</span><span class="st"> </span>adjustVars<span class="op">$</span>W1 <span class="op">+</span><span class="st"> </span>adjustVars<span class="op">$</span>W2)
ftype &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="kw">runif</span>(n, <span class="dv">0</span>, <span class="dv">2</span>))</code></pre></div>
<p>In the above, our simulated data structure is quite similar to the simpler data set that we simulated at the beginning of the present document. The only notable difference is that the failure time variable (again, <code>ftype</code>) now contains <code>r length(unique(ftype))</code> distinct types of failure.</p>
<p>It’s good practice to start with a cursory examination of our data so we’ll do just that.</p>
<pre><code>## # A tibble: 100 x 5
##    ftype ftime   trt    W1    W2
##    &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1     1     4     0     0     1
##  2     1     6     1     1     1
##  3     2     4     1     0     1
##  4     2     4     1     0     2
##  5     1     5     1     0     1
##  6     0     3     1     0     1
##  7     2     4     0     0     1
##  8     0     6     0     0     1
##  9     1     3     1     0     0
## 10     1     5     1     0     2
## # ... with 90 more rows</code></pre>
<p>We can now proceed to invoking the <code>survtmle</code> function to estimate differences in cumulative incidence in this more complex scenario. We’ll start by applying the GLM approach that we saw in several previous examples:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Fit 7: GLM estimators for treatment, censoring, and failure w/ "mean" method</span>
fit7 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="dt">ftime =</span> ftime, <span class="dt">ftype =</span> ftype,
                 <span class="dt">trt =</span> trt, <span class="dt">adjustVars =</span> adjustVars,
                 <span class="dt">glm.trt =</span> <span class="st">"W1 + W2"</span>,
                 <span class="dt">glm.ftime =</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="dt">glm.ctime =</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="dt">method =</span> <span class="st">"mean"</span>, <span class="dt">t0 =</span> t_<span class="dv">0</span>)
fit7</code></pre></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5376047
## 1 1 0.6063805
## 0 2 0.2902382
## 1 2 0.3773405
## 
## $var
##               0 1           1 1           0 2           1 2
## 0 1  0.0057678044  0.0000795576 -3.642272e-03 -2.942690e-05
## 1 1  0.0000795576  0.0056507290  1.215233e-04 -5.467199e-03
## 0 2 -0.0036422725  0.0001215233  4.872782e-03  5.951417e-06
## 1 2 -0.0000294269 -0.0054671994  5.951417e-06  6.640219e-03</code></pre>
<p>Just as in previous examples, we use GLM-based estimators by specifying functional forms for several quantities of interest: the treatment mechanism, the failure time, and the censoring time. We use a TMLE based on the G-computation formula by invoking <code>method = "mean"</code>. As we can see from the output object, we now obtain cumulative incidence estimates for each of the 4 groups defined by the multiple failure types and treatment.</p>
<p>Just as before, we can also abandon the restrictions placed on us by GLMs (that is, the requirement to specify functional forms for the aforementioned quantities of interest) by stacking nonparametric regression procedures using the <code>SuperLearner</code> ensemble learning algorithm. Let’s try that out below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Fit 8: SuperLearner estimators for failure and censoring and empirical</span>
<span class="co">#        estimators for treatment (default) using the "mean" method</span>
fit8 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="dt">ftime =</span> ftime, <span class="dt">ftype =</span> ftype,
                 <span class="dt">trt =</span> trt, <span class="dt">adjustVars =</span> adjustVars,
                 <span class="dt">SL.ftime =</span> <span class="kw">c</span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                 <span class="dt">SL.ctime =</span> <span class="kw">c</span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                 <span class="dt">method =</span> <span class="st">"mean"</span>, <span class="dt">t0 =</span> t_<span class="dv">0</span>)</code></pre></div>
<pre><code>## Warning in checkInputs(ftime = ftime, ftype = ftype, trt = trt, t0 = t0, :
## glm.trt and SL.trt not specified. Proceeding with glm.trt = '1'</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fit8</code></pre></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5447975
## 1 1 0.5683637
## 0 2 0.2871888
## 1 2 0.3431602
## 
## $var
##               0 1           1 1           0 2           1 2
## 0 1  5.143804e-03  7.637143e-06 -3.271772e-03 -2.883737e-06
## 1 1  7.637143e-06  5.029601e-03  1.644025e-06 -4.249492e-03
## 0 2 -3.271772e-03  1.644025e-06  4.265433e-03 -6.978842e-06
## 1 2 -2.883737e-06 -4.249492e-03 -6.978842e-06  4.723240e-03</code></pre>
<p>Just as before, using the nonparametric approach we obtain slightly different estimates (relative to the GLM case) of the cumulative incidence across the combinations of failure types of interest and treatment.</p>
<p>As was the case when we had a single failure type of interest, we can also leverage the method of cause-specific hazards when we have multiple such failure types. We invoke the procedure exactly as we did before using GLMs:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Fit 9: same as Fit 7 above, but using the "hazard" method</span>
fit9 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="dt">ftime =</span> ftime, <span class="dt">ftype =</span> ftype,
                 <span class="dt">trt =</span> trt, <span class="dt">adjustVars =</span> adjustVars,
                 <span class="dt">glm.trt =</span> <span class="st">"W1 + W2"</span>,
                 <span class="dt">glm.ftime =</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="dt">glm.ctime =</span> <span class="st">"trt + W1 + W2"</span>,
                 <span class="dt">method =</span> <span class="st">"hazard"</span>, <span class="dt">t0 =</span> t_<span class="dv">0</span>)</code></pre></div>
<pre><code>## Warning in hazard_tmle(ftime = clean$ftime, ftype = clean$ftype, trt =
## clean$trt, : TMLE fluctuations did not converge. Check that meanIC is
## adequately small and proceed with caution.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fit9</code></pre></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5426655
## 1 1 0.5891886
## 0 2 0.2783585
## 1 2 0.3565178
## 
## $var
##               0 1           1 1           0 2           1 2
## 0 1  6.469106e-03 -4.082243e-03  4.726400e-05 -5.768001e-05
## 1 1 -4.082243e-03  5.030050e-03  5.346433e-05 -6.384787e-05
## 0 2  4.726400e-05  5.346433e-05  9.150187e-03 -8.599396e-03
## 1 2 -5.768001e-05 -6.384787e-05 -8.599396e-03  8.943710e-03</code></pre>
<p>We can also leverage the <code>SuperLearner</code> algorithm when using the method of cause-specific hazards with multiple failure types of interest. This is done essentially the same way as in the case of a single failure type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Fit 10: same as Fit 8 above, but using the "hazard" method</span>
fit10 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="dt">ftime =</span> ftime, <span class="dt">ftype =</span> ftype,
                  <span class="dt">trt =</span> trt, <span class="dt">adjustVars =</span> adjustVars,
                  <span class="dt">SL.ftime =</span> <span class="kw">c</span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                  <span class="dt">SL.ctime =</span> <span class="kw">c</span>(<span class="st">"SL.glm"</span>,<span class="st">"SL.mean"</span>,<span class="st">"SL.step"</span>),
                  <span class="dt">method =</span> <span class="st">"hazard"</span>, <span class="dt">t0 =</span> t_<span class="dv">0</span>)</code></pre></div>
<pre><code>## Warning in checkInputs(ftime = ftime, ftype = ftype, trt = trt, t0 = t0, :
## glm.trt and SL.trt not specified. Proceeding with glm.trt = '1'</code></pre>
<pre><code>## Warning in hazard_tmle(ftime = clean$ftime, ftype = clean$ftype, trt =
## clean$trt, : TMLE fluctuations did not converge. Check that meanIC is
## adequately small and proceed with caution.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fit10</code></pre></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5494984
## 1 1 0.5948570
## 0 2 0.2683959
## 1 2 0.3546066
## 
## $var
##               0 1           1 1           0 2           1 2
## 0 1  5.257412e-03 -3.499796e-03  6.033578e-05 -5.885244e-05
## 1 1 -3.499796e-03  4.138338e-03  5.113174e-05 -3.823377e-05
## 0 2  6.033578e-05  5.113174e-05  6.025102e-03 -5.346442e-03
## 1 2 -5.885244e-05 -3.823377e-05 -5.346442e-03  5.770696e-03</code></pre>
<p>When there are multiple failure types of interest, we can also very easily obtain estimates for only a single failure type. This is done by indicating the failure type of which we desire estimates with the optional <code>ftypeOfInterest</code> argument. This is done like so</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Fit 11: same as Fit 7 above, but now only return estimates for ftype = 1</span>
fit11 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="dt">ftime =</span> ftime, <span class="dt">ftype =</span> ftype,
                  <span class="dt">trt =</span> trt, <span class="dt">adjustVars =</span> adjustVars,
                  <span class="dt">glm.trt =</span> <span class="st">"W1 + W2"</span>,
                  <span class="dt">glm.ftime =</span> <span class="st">"trt + W1 + W2"</span>,
                  <span class="dt">glm.ctime =</span> <span class="st">"trt + W1 + W2"</span>,
                  <span class="dt">method =</span> <span class="st">"mean"</span>, <span class="dt">t0 =</span> t_<span class="dv">0</span>,
                  <span class="dt">ftypeOfInterest =</span> <span class="dv">1</span>)
fit11</code></pre></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5376047
## 1 1 0.6063805
## 
## $var
##              0 1          1 1
## 0 1 0.0057678044 0.0000795576
## 1 1 0.0000795576 0.0056507290</code></pre>
<p>When there are multiple failure types of interest, we can still provide bounds for the iterated conditional means (or the conditional hazard function, whichever is appropriate based on our specification of the <code>method</code> argument).</p>
<p>In such cases, we must specify bounds associated with each of the failure types of interest. Since we now have 2 such failure types, we must specify just as many bounds:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># need to make a data.frame of bounds in proper format two types of failure that</span>
<span class="co"># are labeled with ftype = 1 and ftype = 2, so bounds should have columns 't',</span>
<span class="co"># 'l1', 'u1', 'l2', and 'u2'.</span>
bf2 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">t =</span> <span class="kw">seq_len</span>(t_<span class="dv">0</span>),
                  <span class="dt">l1 =</span> <span class="kw">rep</span>(<span class="fl">0.01</span>, t_<span class="dv">0</span>), <span class="dt">u1 =</span> <span class="kw">rep</span>(<span class="fl">0.99</span>, t_<span class="dv">0</span>),
                  <span class="dt">l2 =</span> <span class="kw">rep</span>(<span class="fl">0.02</span>, t_<span class="dv">0</span>), <span class="dt">u2 =</span> <span class="kw">rep</span>(<span class="fl">0.99</span>, t_<span class="dv">0</span>)
                 )
bf2</code></pre></div>
<pre><code>##   t   l1   u1   l2   u2
## 1 1 0.01 0.99 0.02 0.99
## 2 2 0.01 0.99 0.02 0.99
## 3 3 0.01 0.99 0.02 0.99
## 4 4 0.01 0.99 0.02 0.99
## 5 5 0.01 0.99 0.02 0.99
## 6 6 0.01 0.99 0.02 0.99</code></pre>
<p>Now, we invoke <code>survtmle</code>, passing in the specified bounds using the appropriate argument:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Fit 12: same as Fit 7 above, but now include bounds</span>
fit12 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/survtmle.html">survtmle</a></span>(<span class="dt">ftime =</span> ftime, <span class="dt">ftype =</span> ftype,
                  <span class="dt">trt =</span> trt, <span class="dt">adjustVars =</span> adjustVars,
                  <span class="dt">glm.trt =</span> <span class="st">"W1 + W2"</span>,
                  <span class="dt">glm.ftime =</span> <span class="st">"trt + W1 + W2"</span>,
                  <span class="dt">glm.ctime =</span> <span class="st">"trt + W1 + W2"</span>,
                  <span class="dt">method =</span> <span class="st">"mean"</span>, <span class="dt">t0 =</span> t_<span class="dv">0</span>,
                  <span class="dt">bounds =</span> bf2)
fit12</code></pre></div>
<pre><code>## $est
##          [,1]
## 0 1 0.5375305
## 1 1 0.6063561
## 0 2 0.2904554
## 1 2 0.3782845
## 
## $var
##               0 1           1 1           0 2           1 2
## 0 1  5.767775e-03  7.979253e-05 -3.640610e-03 -2.906808e-05
## 1 1  7.979253e-05  5.651563e-03  1.225822e-04 -5.467546e-03
## 0 2 -3.640610e-03  1.225822e-04  4.883753e-03  5.150747e-06
## 1 2 -2.906808e-05 -5.467546e-03  5.150747e-06  6.695540e-03</code></pre>
<p>Having thoroughly examined the major options available in the <code>survtmle</code> function, let us proceed to inspect a few of the utility functions the package provides.</p>
<hr>
</div>
<div id="utility-functions" class="section level2">
<h2 class="hasAnchor">
<a href="#utility-functions" class="anchor"></a>Utility functions</h2>
<ul>
<li>Brief look at <code>timepoints</code>
</li>
<li>Brief look at <code>plot.tp.survtmle</code>
</li>
</ul>
<hr>
</div>
<div id="applied-data-analysis-practical" class="section level2">
<h2 class="hasAnchor">
<a href="#applied-data-analysis-practical" class="anchor"></a>Applied Data Analysis Practical</h2>
<p>Coming soon…</p>
<hr>
</div>
<div id="session-information" class="section level2">
<h2 class="hasAnchor">
<a href="#session-information" class="anchor"></a>Session Information</h2>
<pre><code>## R version 3.4.1 (2017-06-30)
## Platform: x86_64-apple-darwin16.6.0 (64-bit)
## Running under: macOS Sierra 10.12.5
## 
## Matrix products: default
## BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
## LAPACK: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libLAPACK.dylib
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] nnls_1.4       survtmle_0.1.2 tibble_1.3.3  
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.11        knitr_1.16          magrittr_1.5       
##  [4] munsell_0.4.3       colorspace_1.3-2    lattice_0.20-35    
##  [7] rlang_0.1.1.9000    stringr_1.2.0.9000  plyr_1.8.4         
## [10] tools_3.4.1         grid_3.4.1          gtable_0.2.0       
## [13] SuperLearner_2.0-22 htmltools_0.3.6     yaml_2.1.14        
## [16] lazyeval_0.2.0      rprojroot_1.2       digest_0.6.12      
## [19] Matrix_1.2-10       purrr_0.2.2.9000    tidyr_0.6.3.9000   
## [22] ggplot2_2.2.1.9000  glue_1.1.1          evaluate_0.10.1    
## [25] rmarkdown_1.6       stringi_1.1.5       compiler_3.4.1     
## [28] scales_0.4.1.9002   backports_1.1.0</code></pre>
<hr>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h2>
<div id="refs" class="references">
<div id="ref-bang2005doubly">
<p>Bang, Heejung, and James M Robins. 2005. “Doubly Robust Estimation in Missing Data and Causal Inference Models.” <em>Biometrics</em> 61 (4). Wiley Online Library: 962–73.</p>
</div>
<div id="ref-breiman1996stacked">
<p>Breiman, Leo. 1996. “Stacked Regressions.” <em>Machine Learning</em> 24 (1). Springer: 49–64.</p>
</div>
<div id="ref-vdl2011targeted">
<p>van der Laan, Mark J, and Sherri Rose. 2011. <em>Targeted Learning: Causal Inference for Observational and Experimental Data</em>. Springer Science &amp; Business Media.</p>
</div>
<div id="ref-vdl2017targeted">
<p>———. 2017. <em>Targeted Learning in Data Science: Causal Inference for Complex Longitudinal Studies</em>. Springer Science &amp; Business Media.</p>
</div>
<div id="ref-vdl2007super">
<p>van der Laan, Mark J, Eric C Polley, and Alan E Hubbard. 2007. “Super Learner.” <em>Statistical Applications in Genetics and Molecular Biology</em> 6 (1).</p>
</div>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li><a href="#simulation">Simulation</a></li>
      <li><a href="#using-the-g-computation-method">Using the G-computation method</a></li>
      <li><a href="#using-the-method-of-cause-specific-hazards">Using the method of cause-specific hazards</a></li>
      <li><a href="#bounded-tmles">Bounded TMLEs</a></li>
      <li><a href="#assessing-multiple-failure-types">Assessing Multiple Failure Types</a></li>
      <li><a href="#utility-functions">Utility functions</a></li>
      <li><a href="#applied-data-analysis-practical">Applied Data Analysis Practical</a></li>
      <li><a href="#session-information">Session Information</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by David Benkeser, Nima Hejazi.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
